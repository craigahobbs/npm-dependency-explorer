# Licensed under the MIT License
# https://github.com/craigahobbs/craigahobbs.github.io/blob/main/LICENSE


# Create a new SemVer object
function semverNew(major, minor, patch, release)
    semver = objectNew( \
        'major', major, \
        'minor', minor, \
        'patch', patch, \
        'release', release, \
        'build', null \
    )
    return semver
endfunction


# Parse SemVer text to a SemVer object
function semverParse(text, groupSuffix)
    semver = null

    # Match the SemVer text
    match = if(stringLength(text) != null, regexMatch(semverRegexSemver, text), text)
    if match != null then
        groups = objectGet(match, 'groups')
        if groupSuffix == null then
            groupSuffix = ''
        endif

        # Parse the release text
        release = null
        releaseText = objectGet(groups, 'release' + groupSuffix)
        if releaseText != null then
            release = arrayNew()
            foreach part in stringSplit(releaseText, '.') do
                # Parse all-digits parts as integers
                part = if(regexMatch(semverRegexDigits, part) != null, numberParseInt(part), part)
                arrayPush(release, part)
            endforeach
        endif

        # Return the SemVer object
        major = objectGet(groups, 'major' + groupSuffix)
        minor = objectGet(groups, 'minor' + groupSuffix)
        patch = objectGet(groups, 'patch' + groupSuffix)
        build = objectGet(groups, 'build' + groupSuffix)
        semver = objectNew( \
            'major', if(regexTest(semverRegexDigits, major), numberParseInt(major), 0), \
            'minor', if(regexTest(semverRegexDigits, minor), numberParseInt(minor), 0), \
            'patch', if(regexTest(semverRegexDigits, patch), numberParseInt(patch), 0), \
            'release', release, \
            'build', build \
        )
    endif

    return semver
endfunction


# SemVer parsing regular expressions
semverRegexStrReleaseBuild = \
    '(?:-(?<release>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?' + \
    '(?:\\+(?<build>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?'
semverRegexSemver = regexNew('^(?<major>0|[1-9]\\d*)\\.(?<minor>0|[1-9]\\d*)\\.(?<patch>0|[1-9]\\d*)' + semverRegexStrReleaseBuild + '$')
semverRegexDigits = regexNew('^\d+$')


# Stringify a SemVer object
function semverStringify(semver)
    release = objectGet(semver, 'release')
    build = objectGet(semver, 'build')
    return arrayJoin(arrayNew( \
        objectGet(semver, 'major'), '.', \
        objectGet(semver, 'minor'), '.', \
        objectGet(semver, 'patch'), \
        if(release != null, '-' + arrayJoin(release, '.'), ''), \
        if(build != null, '+' + build, '') \
    ), '')
endfunction


# SemVer sort comparison func
function semverCompare(semver, other)
    # Compare the major version
    semverMajor = objectGet(semver, 'major')
    otherMajor = objectGet(other, 'major')
    result = if(semverMajor < otherMajor, -1, if(semverMajor == otherMajor, 0, 1))

    # Compare the minor version
    if !result then
        semverMinor = objectGet(semver, 'minor')
        otherMinor = objectGet(other, 'minor')
        result = if(semverMinor < otherMinor, -1, if(semverMinor == otherMinor, 0, 1))
    endif

    # Compare the patch version
    if !result then
        semverPatch = objectGet(semver, 'patch')
        otherPatch = objectGet(other, 'patch')
        result = if(semverPatch < otherPatch, -1, if(semverPatch == otherPatch, 0, 1))
    endif

    # Compare the release
    if !result then
        semverRelease = objectGet(semver, 'release')
        otherRelease = objectGet(other, 'release')
        result = if(semverRelease != null, if(otherRelease != null, 0, -1), if(otherRelease != null, 1, 0))
    endif

    # Compare the release parts
    if !result then
        semverReleaseLength = arrayLength(semverRelease)
        otherReleaseLength = arrayLength(otherRelease)
        releaseLength = mathMax(semverReleaseLength, otherReleaseLength)
        ixPart = 0
        while ixPart < releaseLength do
            semverReleasePart = arrayGet(semverRelease, ixPart)
            otherReleasePart = arrayGet(otherRelease, ixPart)

            # Numeric parts are less-than non-numeric parts
            semverPartNumeric = (stringLength(semverReleasePart) == null)
            otherPartNumeric = (stringLength(otherReleasePart) == null)
            result = if(semverPartNumeric && !otherPartNumeric, -1, if(!semverPartNumeric && otherPartNumeric, 1, 0))
            if result then
                break
            endif

            # Compare the parts
            result = if(semverReleasePart < otherReleasePart, -1, if(semverReleasePart == otherReleasePart, 0, 1))
            if result then
                break
            endif

            ixPart = ixPart + 1
        endwhile
    endif

    # Compare the release parts lengths
    if !result then
        result = if(semverReleaseLength < otherReleaseLength, -1, if(semverReleaseLength == otherReleaseLength, 0, 1))
    endif

    # Compare the build
    if !result then
        semverBuild = objectGet(semver, 'build')
        otherBuild = objectGet(other, 'build')
        result = if(semverBuild != null, if(otherBuild != null, 0, 1), if(otherBuild != null, -1, 0))
        if !result then
            result = if(semverBuild < otherBuild, -1, if(semverBuild == otherBuild, 0, 1))
        endif
    endif

    return result
endfunction


# SemVer reverse-sort comparison func
function semverCompareReversed(semver, other)
    return -semverCompare(semver, other)
endfunction


# Parse an array of SemVer text to an array of SemVer objects
function semverVersions(versions)
    semvers = arrayNew()
    foreach version in versions do
        semver = semverParse(version)
        if semver != null then
            objectSet(semver, 'semver', objectCopy(semver))
            arrayPush(semvers, semver)
        else then
            debugLog('semver: Unrecognized SemVer "' + version + '"')
        endif
    endforeach
    return arraySort(semvers, semverCompareReversed)
endfunction


# Match a SemVer range
function semverMatch(semvers, range)
    # Compute all matched semvers
    matchedSemvers = arrayNew()
    foreach rangePart in stringSplit(range, semverRegexRangePartSplit) do
        partSemvers = semverMatchPart(semvers, rangePart)
        if partSemvers != null then
            arrayExtend(matchedSemvers, partSemvers)
        endif
    endforeach

    # Compute the best match
    if arrayLength(matchedSemvers) then
        arraySort(matchedSemvers, semverCompareReversed)
        return semverStringify(arrayGet(matchedSemvers, 0))
    endif

    return null
endfunction


# Match a SemVer range part
function semverMatchPart(semvers, range)
    # Tilde range
    matchTilde = regexMatch(semverRegexTilde, range)
    if matchTilde != null then
        groups = objectGet(matchTilde, 'groups')
        lower = semverParse(matchTilde)
        upper = semverNew(objectGet(lower, 'major'), objectGet(lower, 'minor') + 1, 0)
        return dataFilter( \
            semvers, \
            'semverCompare(semver, lower) >= 0 && semverCompare(semver, upper) < 0', \
            objectNew('lower', lower, 'upper', upper) \
        )
    endif

    # Carrot range
    matchCarrot = regexMatch(semverRegexCarrot, range)
    if matchCarrot != null then
        groups = objectGet(matchCarrot, 'groups')
        lower = semverParse(matchCarrot)
        major = objectGet(lower, 'major')
        minor = objectGet(lower, 'minor')
        patch = objectGet(lower, 'patch')
        upper = semverNew( \
            if(major >= 1, major + 1, major), \
            if(major >= 1, 0, if(minor >= 1, minor + 1, minor)), \
            if(major >= 1, 0, if(minor >= 1, 0, patch + 1)), \
            arrayNew(0) \
        )
        filtered = dataFilter( \
            semvers, \
            'semverCompare(semver, lower) >= 0 && semverCompare(semver, upper) < 0', \
            objectNew('lower', lower, 'upper', upper) \
        )
        return dataFilter( \
            filtered, \
            'release == null || (major == lowerMajor && minor == lowerMinor && patch == lowerPatch)', \
            objectNew('lower', lower, 'upper', upper, 'lowerMajor', major, 'lowerMinor', minor, 'lowerPatch', patch) \
        )
    endif

    # Hypen range
    matchHyphen = regexMatch(semverRegexHyphen, range)
    if matchHyphen != null then
        lower = semverParse(matchHyphen)
        upper = semverParse(matchHyphen, '2')
        groups = objectGet(matchHyphen, 'groups')
        hasUpperPatch = regexTest(semverRegexDigits, objectGet(groups, 'patch2'))
        return dataFilter( \
            semvers, \
            "objectGet(semver, 'release') == null && semverCompare(semver, lower) >= 0 && " + \
                'if(hasUpperPatch, semverCompare(semver, upper) <= 0, semverCompare(semver, upper) < 0)', \
            objectNew('lower', lower, 'upper', upper, 'hasUpperPatch', hasUpperPatch) \
        )
    endif

    # Empty range?
    if range == '' then
        return dataFilter(semvers, "objectGet(semver, 'release') == null")
    endif

    # Range
    filtered = semvers
    rangeParts = range
    matchRangePart = regexMatch(semverRegexRangePart, rangeParts)
    while matchRangePart != null do
        groups = objectGet(matchRangePart, 'groups')
        rangeOp = objectGet(groups, 'op')
        rangeValue = semverParse(matchRangePart)
        rangeValueHasMajor = regexTest(semverRegexDigits, objectGet(groups, 'major'))
        rangeValueHasMinor = regexTest(semverRegexDigits, objectGet(groups, 'minor'))
        rangeValueHasPatch = regexTest(semverRegexDigits, objectGet(groups, 'patch'))

        if (rangeOp == '' || rangeOp == '=') && !rangeValueHasMajor then
            filtered = dataFilter(filtered, "objectGet(semver, 'release') == null")
        else if rangeOp == '=' || (rangeOp == '' && rangeValueHasPatch) then
            filtered = dataFilter(filtered, 'semverCompare(semver, rangeValue) == 0', objectNew('rangeValue', rangeValue))
        else if rangeOp == '' then
            if rangeValueHasMinor then
                upper = semverNew(objectGet(rangeValue, 'major'), objectGet(rangeValue, 'minor') + 1, 0)
            else then
                upper = semverNew(objectGet(rangeValue, 'major') + 1, 0, 0, '0')
            endif
            filtered = dataFilter( \
                filtered, \
                "objectGet(semver, 'release') == null && semverCompare(semver, lower) >= 0 && semverCompare(semver, upper) < 0", \
                objectNew('lower', rangeValue, 'upper', upper) \
            )
        else then
            filtered = dataFilter( \
                filtered, \
                "objectGet(semver, 'release') == null && semverCompare(semver, rangeValue) " + rangeOp + ' 0', \
                objectNew('rangeValue', rangeValue) \
            )
        endif

        rangeParts = stringSlice(rangeParts, stringLength(arrayGet(matchRangePart, 0)))
        matchRangePart = regexMatch(semverRegexRangePart, rangeParts)
    endwhile

    # Syntax error?
    if rangeParts != '' then
        return null
    endif

    return filtered
endfunction


# SemVer range regular expressions
semverRegexRangePartSplit = regexNew('\\s*\\|\\|\\s*')
semverRegexStrVersion = \
    '(?<major>[xX*]|0|[1-9]\\d*)(?:\\.(?<minor>[xX*]|0|[1-9]\\d*)(?:\\.(?<patch>[xX*]|0|[1-9]\\d*)' + semverRegexStrReleaseBuild + ')?)?'
semverRegexStrVersion2 = stringReplace(stringReplace(stringReplace(stringReplace(stringReplace(semverRegexStrVersion, \
    '<major>', '<major2>'), '<minor>', '<minor2>'), '<patch>', '<patch2>'), '<release>', '<release2>'), '<build>', '<build2>')
semverRegexVersion = regexNew('^' + semverRegexStrVersion + '$')
semverRegexRangePart = regexNew('^(?<op>|=|<|<=|>|>=)\\s*' + semverRegexStrVersion + '\\s*')
semverRegexCarrot = regexNew('^\\^\\s*' + semverRegexStrVersion + '$')
semverRegexHyphen = regexNew('^' + semverRegexStrVersion + '\\s+-\\s+' + semverRegexStrVersion2 + '$')
semverRegexTilde = regexNew('^~\\s*' + semverRegexStrVersion + '$')
