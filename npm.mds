# Licensed under the MIT License
# https://github.com/craigahobbs/craigahobbs.github.io/blob/main/LICENSE

include 'semver.mds'


# Create an npm package page URL
function npmPackagePageURL(packageName)
    return 'https://www.npmjs.com/package/' + encodeURIComponent(packageName)
endfunction


# Create an npm package data URL
function npmPackageURL(packageName)
    return 'https://registry.npmjs.org/' + encodeURIComponent(packageName)
endfunction


# Initialize the package data cache
function npmCacheNew()
    return objectNew( \
        'packages', objectNew(), \
        'versions', objectNew(), \
        'ranges', objectNew(), \
        'dependencies', objectNew(), \
        'dependenciesContained', objectNew() \
    )
endfunction


# Get package data from the cache
function npmCacheGetPackage(cache, packageName)
    return objectGet(objectGet(cache, 'packages'), packageName)
endfunction


# Get package versions from the cache
function npmCacheGetPackageVersions(cache, packageName)
    return objectGet(objectGet(cache, 'versions'), packageName)
endfunction


# Get a package version's JSON
function npmPackageJSON(packageData, packageVersion)
    return objectGet(objectGet(packageData, 'versions'), packageVersion)
endfunction


# Get a package's latest version
function npmPackageVersionLatest(packageData)
    return objectGet(objectGet(packageData, 'dist-tags'), 'latest')
endfunction


# Get a package version from a semver range
function npmCacheGetPackageVersion(cache, packageName, packageRange)
    # Has the semver range already been matched?
    packageRanges = objectGet(objectGet(cache, 'ranges'), packageName)
    if objectHas(packageRanges, packageRange) then
        packageVersion = objectGet(packageRanges, packageRange)
    else then
        # Compute the version for the semver range
        packageVersions = objectGet(objectGet(cache, 'versions'), packageName)
        packageVersion = semverMatch(packageVersions, packageRange)

        #!! SemVer matching is incomplete, so fall back to the latest version
        if packageVersion == null then
            packageVersion = npmPackageVersionLatest(npmCacheGetPackage(cache, packageName))
        endif

        # Warn about unmatched SemVer ranges
        if packageVersion == null then
            debugLog('npm: Unrecognized SemVer range "' + packageRange + '" for package "' + packageName + '"')
        endif

        # Update the range cache
        objectSet(packageRanges, packageRange, packageVersion)
    endif
    return packageVersion
endfunction


# Load a package version and its dependencies into the cache
async function npmLoadPackage(cache, packageName, packageVersion, dependencyKey)
    # Package already loaded?
    cachePackages = objectGet(cache, 'packages')
    if objectHas(cachePackages, packageName) then
        packageData = objectGet(cachePackages, packageName)
    else then
        # Fetch the package data
        packageData = fetch(npmPackageURL(packageName))

        # Update the package cache
        npmCacheAddPackage(cache, packageName, packageData)
    endif

    # Get the package version JSON
    if packageVersion == null then
        packageVersion = if(packageData != null, npmPackageVersionLatest(packageData))
    endif
    packageJSON = if(packageData != null && packageVersion != null, npmPackageJSON(packageData, packageVersion))

    # Load the package JSON's dependencies
    if packageJSON != null then
        npmLoadPackage2(cache, arrayNew(packageJSON), dependencyKey)
    endif

    return packageJSON
endfunction


# Load a package version and its dependencies into the cache
async function npmLoadPackageAllVersions(cache, packageName, dependencyKey)
    # Package must be already loaded?
    packageData = objectGet(objectGet(cache, 'packages'), packageName)
    if packageData != null then
        # Get the package version JSONs
        packageJSONs = arrayNew()
        packageVersions = objectGet(packageData, 'versions')
        foreach packageVersion in objectKeys(packageVersions) do
            arrayPush(packageJSONs, objectGet(packageVersions, packageVersion))
        endforeach

        # Load the package JSON's dependencies
        if arrayLength(packageJSONs) then
            npmLoadPackage2(cache, packageJSONs, dependencyKey)
        endif
    endif
endfunction


# Add package data to the cache
function npmCacheAddPackage(cache, packageName, packageData)
    # Add the package data to the cache
    objectSet(objectGet(cache, 'packages'), packageName, packageData)

    # Add the parsed semver array to the cache
    versionKeys = if(packageData != null, objectKeys(objectGet(packageData, 'versions')))
    versions = if(versionKeys != null, semverVersions(versionKeys), arrayNew())
    objectSet(objectGet(cache, 'versions'), packageName, versions)

    # Add the empty semver match map
    objectSet(objectGet(cache, 'ranges'), packageName, objectNew())
endfunction


# Recursively load a package's data
async function npmLoadPackage2(cache, packageJSONs, dependencyKey)
    cachePackages = objectGet(cache, 'packages')
    cacheRanges = objectGet(cache, 'ranges')

    # Compute the unloaded dependencies for the given package JSON
    unloadedNames = objectNew()
    unloadedRanges = arrayNew()
    foreach packageJSON in packageJSONs do
        # Get the package dependencies
        packageDependencies = objectGet(packageJSON, dependencyKey)
        if packageDependencies == null then
            continue
        endif
        dependencyNames = objectKeys(packageDependencies)
        if arrayLength(dependencyNames) == 0 then
            continue
        endif

        # Add to the unloaded dependencies
        foreach dependencyName in dependencyNames do
            dependencyRange = objectGet(packageDependencies, dependencyName)

            # Add the unloaded dependency package
            if !objectHas(cachePackages, dependencyName) then
                objectSet(unloadedNames, dependencyName)
            endif

            # Add the unloaded dependency range
            dependencyRanges = objectGet(cacheRanges, dependencyName)
            if !objectHas(dependencyRanges, dependencyRange) then
                arrayPush(unloadedRanges, arrayNew(dependencyName, dependencyRange))
            endif
        endforeach
    endforeach

    # Compute the package data URLs for the unloaded dependency package names
    unloadedNames = objectKeys(unloadedNames)
    unloadedURLs = arrayNew()
    foreach unloadedName in unloadedNames do
        arrayPush(unloadedURLs, npmPackageURL(unloadedName))
    endforeach

    # Fetch the unloaded depedency data URLs
    foreach dependencyData, ixDependencyData in fetch(unloadedURLs) do
        dependencyName = arrayGet(unloadedNames, ixDependencyData)

        # Was the package unpublished?
        if dependencyData != null && objectHas(dependencyData, 'unpublished') then
            dependencyData = null
        endif

        # Add the dependency package data to the cache
        npmCacheAddPackage(cache, dependencyName, dependencyData)
    endforeach

    # Get the array of unloaded package JSON
    unloadedJSONs = arrayNew()
    foreach unloadedNameRange in unloadedRanges do
        unloadedName = arrayGet(unloadedNameRange, 0)
        unloadedRange = arrayGet(unloadedNameRange, 1)

        # Has the package range already been computed?
        unloadedRanges = objectGet(cacheRanges, unloadedName)
        if objectHas(unloadedRanges, unloadedRange) then
            continue
        endif

        # Compute the package range version
        unloadedData = npmCacheGetPackage(cache, unloadedName)
        if unloadedData != null then
            unloadedVersion = npmCacheGetPackageVersion(cache, unloadedName, unloadedRange)
            if unloadedVersion != null then
                unloadedJSON = npmPackageJSON(unloadedData, unloadedVersion)
                if unloadedJSON != null then
                    arrayPush(unloadedJSONs, unloadedJSON)
                endif
            endif
        endif
    endforeach

    # Compute the dependencies' dependencies
    if arrayLength(unloadedJSONs) then
        npmLoadPackage2(cache, unloadedJSONs, 'dependencies')
    endif
endfunction


# Get a package's total dependency count
function npmPackageDependencyCount(cache, packageName, packageVersion)
    dependencies = arrayNew()
    warnings = arrayNew()
    npmPackageDependencies(cache, dependencies, warnings, packageName, packageVersion, 'dependencies')
    dependenciesTotal = dataAggregate(dependencies, objectNew( \
        'categories', arrayNew('Package', 'Version'), \
        'measures', arrayNew( \
            objectNew('field', 'Count', 'function', 'count') \
        ) \
    ))
    return arrayLength(dependenciesTotal)
endfunction


# Compute a package's total and direct dependencies with warnings
function npmPackageStats(cache, packageName, packageVersion, dependencyKey)
    # Get the package dependencies
    dependencies = arrayNew()
    warnings = arrayNew()
    npmPackageDependencies(cache, dependencies, warnings, packageName, packageVersion, dependencyKey)

    # Compute the dependency statistics
    dependenciesDirect = dataFilter(dependencies, 'Dependent == packageName && [Dependent Version] == packageVersion', \
        objectNew('packageName', packageName, 'packageVersion', packageVersion))
    dependenciesTotal = dataAggregate(dependencies, objectNew( \
        'categories', arrayNew('Package', 'Version'), \
        'measures', arrayNew( \
            objectNew('field', 'Count', 'function', 'count') \
        ) \
    ))

    # Multiple-dependency-version warning?
    dependenciesMultiple = dataFilter( \
        dataAggregate(dependenciesTotal, objectNew( \
            'categories', arrayNew('Package'), \
            'measures', arrayNew( \
                objectNew('field', 'Count', 'function', 'count') \
            ) \
        )), \
        'Count > 1' \
    )
    if arrayLength(dependenciesMultiple) then
        dataSort(dependenciesTotal, arrayNew(arrayNew('Package'), arrayNew('Version')))
        dataSort(dependenciesMultiple, arrayNew(arrayNew('Package'), arrayNew('Version')))
        foreach dependency in dependenciesMultiple do
            dependencyName = objectGet(dependency, 'Package')
            dependencyVersions = dataFilter(dependenciesTotal, 'Package == dependencyName', objectNew('dependencyName', dependencyName))
            versions = arrayNew()
            foreach dependencyVersion in dependencyVersions do
                arrayPush(versions, '"' + objectGet(dependencyVersion, 'Version') + '"')
            endforeach
            arrayPush(warnings, 'Multiple versions of package "' + dependencyName + '" (' + arrayJoin(versions, ', ') + ')')
        endforeach
    endif

    # Return the dependency statistics
    return objectNew( \
        'count', arrayLength(dependenciesTotal), \
        'countDirect', arrayLength(dependenciesDirect), \
        'dependencies', dependencies, \
        'dependenciesDirect', dependenciesDirect, \
        'warnings', warnings \
    )
endfunction


# Compute an npm package's dependency data table
function npmPackageDependencies(cache, dependencies, warnings, packageName, packageVersion, dependencyKey, completed)
    completed = if(completed != null, completed, objectNew())

    # Package and version already loaded?
    if !objectHas(completed, packageName) then
        objectSet(completed, packageName, objectNew())
    endif
    completedVersions = objectGet(completed, packageName)
    if objectHas(completedVersions, packageVersion) then
        return
    endif
    objectSet(completedVersions, packageVersion)

    # Get the package dependencies object
    packageData = npmCacheGetPackage(cache, packageName)
    packageJSON = npmPackageJSON(packageData, packageVersion)
    packageDependencies = objectGet(packageJSON, dependencyKey)
    dependencyNames = if(packageDependencies != null, objectKeys(packageDependencies))
    if dependencyNames != null && arrayLength(dependencyNames) == 0 then
        return
    endif

    # Add the package dependency rows
    foreach dependencyName in dependencyNames do
        # Determine the dependency version
        dependencyRange = objectGet(packageDependencies, dependencyName)
        dependencyVersion = npmCacheGetPackageVersion(cache, dependencyName, dependencyRange)
        if dependencyVersion == null then
            arrayPush(warnings, 'Unknown version "' + dependencyVersion + '" of package "' + dependencyName + '"')
        endif

        # Compute the latest version
        dependencyData = npmCacheGetPackage(cache, dependencyName)
        dependencyLatest = npmPackageVersionLatest(dependencyData)

        if dependencyVersion != null then
            # Add the dependency row
            arrayPush(dependencies, objectNew( \
                'Package', dependencyName, \
                'Version', dependencyVersion, \
                'Latest', if(dependencyVersion == dependencyLatest, '', dependencyLatest), \
                'Range', dependencyRange, \
                'Dependent', packageName, \
                'Dependent Version', packageVersion \
            ))

            # Add the dependency's dependencies
            npmPackageDependencies(cache, dependencies, warnings, dependencyName, dependencyVersion, 'dependencies', completed)
        endif
    endforeach
endfunction
